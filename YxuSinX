if getgenv().eclipsehub then warn("Eclipse Hub is already executed") return end
getgenv().eclipsehub = true

loadstring([[
    function LPH_NO_VIRTUALIZE(f) return f end;
]])();

local debris = game:GetService("Debris")
local contentProvider = game:GetService("ContentProvider")
local scriptContext = game:GetService("ScriptContext")
local players = game:GetService("Players")
local tweenService = game:GetService("TweenService")
local statsService = game:GetService("Stats")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local starterGui = game:GetService("StarterGui")

local player = players.LocalPlayer
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera
local values = replicatedStorage:FindFirstChild("Values")

local IS_PRACTICE = game.PlaceId == 8206123457
local IS_SOLARA = string.match(getexecutorname(), "Solara")
local AC_BYPASS = IS_PRACTICE

local moveToUsing = {}

if not values or IS_PRACTICE then
	if replicatedStorage:FindFirstChild("Values") then
		replicatedStorage:FindFirstChild("Values"):Destroy()
	end
	values = Instance.new("Folder")
	local status = Instance.new("StringValue")
	status.Name = "Status"
	status.Value = "InPlay"
	status.Parent = values
	values.Parent = replicatedStorage
	values.Name = "Values"
end

if not LPH_OBFUSCATED then
    getfenv().LPH_NO_VIRTUALIZE = function(f) return f end
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Handshake = ReplicatedStorage.Remotes.CharacterSoundEvent
local Hooks = {}
local HandshakeInts = {}

LPH_NO_VIRTUALIZE(function()
    for i, v in getgc() do
        if typeof(v) == "function" and islclosure(v) then
            if (#getprotos(v) == 1) and table.find(getconstants(getproto(v, 1)), 4000001) then
                hookfunction(v, function() end)
            end
        end
    end
end)()

Hooks.__namecall = hookmetamethod(game, "__namecall", LPH_NO_VIRTUALIZE(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}

    if not checkcaller() and (self == Handshake) and (Method == "fireServer") and (string.find(Args[1], "AC")) then
        if (#HandshakeInts == 0) then
            HandshakeInts = {table.unpack(Args[2], 2, 18)}
        else
            for i, v in HandshakeInts do
                Args[2][i + 1] = v
            end
        end
    end

    return Hooks.__namecall(self, ...)
end))

task.wait(1)

if not isfolder("eclipsehub") then
	makefolder("eclipsehub")
end

local ping = 0
local fps = 0

-- Load Fluent UI Library
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- Show welcome notification
Fluent:Notify({
    Title = "Eclipse Hub",
    Content = "Successfully loaded FF2 script",
    Duration = 5
})

-- Create the main window with increased height
local Window = Fluent:CreateWindow({
    Title = "Eclipse Hub - Football Fusion 2",
    SubTitle = "by Veylo",
    TabWidth = 160,
    Size = UDim2.fromOffset(595, 365),  -- Increased height from 460 to 560
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl,
    CanResize = true,
    ScrollSpeed = 30,
    ScrollingEnabled = true
})

-- Create tabs with enforced scrolling
local Tabs = {
    Catching = Window:AddTab({ Title = "Catching", Icon = "radio", ScrollingEnabled = true }),
    Physics = Window:AddTab({ Title = "Physics", Icon = "rocket", ScrollingEnabled = true }),
    Auto = Window:AddTab({ Title = "Auto", Icon = "bot", ScrollingEnabled = true }),
    Throwing = Window:AddTab({ Title = "Throwing", Icon = "send", ScrollingEnabled = true }),
    Player = Window:AddTab({ Title = "Player", Icon = "user", ScrollingEnabled = true }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings", ScrollingEnabled = true })
}

-- Options storage to reference values
local Options = Fluent.Options

-- QuickTP Feature
local QuickTPToggle = Tabs.Physics:AddToggle("QuickTP", {
    Title = "Quick TP",
    Default = false,
    Description = "Teleport quickly in the direction you're moving"
})

local QuickTPSpeed = Tabs.Physics:AddSlider("QuickTPSpeed", {
    Title = "Speed",
    Description = "QuickTP speed multiplier",
    Default = 3,
    Min = 1,
    Max = 5,
    Rounding = 0
})

local QuickTPBind = Tabs.Physics:AddKeybind("QuickTPBind", {
    Title = "Keybind",
    Default = "F",
    Mode = "Toggle", -- Always, Toggle, Hold
    Description = "Key to activate Quick TP"
})

-- Click Tackle Aimbot
local ClickTackleAimbotToggle = Tabs.Physics:AddToggle("ClickTackleAimbot", {
    Title = "Click Tackle Aimbot",
    Default = false,
    Description = "Teleport to the ball carrier when clicking"
})

local ClickTackleAimbotDistance = Tabs.Physics:AddSlider("ClickTackleAimbotDistance", {
    Title = "Distance",
    Description = "Maximum teleport distance",
    Default = 7,
    Min = 0,
    Max = 15,
    Rounding = 0
})

-- Anti Jam/Block toggles
local AntiJamToggle = Tabs.Physics:AddToggle("AntiJam", {
    Title = "Anti Jam",
    Default = false,
    Description = "Prevents you from getting jammed"
})

local AntiBlockToggle = Tabs.Physics:AddToggle("AntiBlock", {
    Title = "Anti Block",
    Default = false,
    Description = "Prevents players from blocking you"
})

-- Visualize Ball Path
local VisualizeBallPathToggle = Tabs.Physics:AddToggle("VisualizeBallPath", {
    Title = "Visualize Ball Path",
    Default = false,
    Description = "Shows the path of the ball"
})

-- No Jump Cooldown
local NoJumpCooldownToggle = Tabs.Physics:AddToggle("NoJumpCooldown", {
    Title = "No Jump Cooldown",
    Default = false,
    Description = "Removes the cooldown between jumps"
})

-- No Freeze
local NoFreezeToggle = Tabs.Physics:AddToggle("NoFreeze", {
    Title = "No Freeze",
    Default = false,
    Description = "Prevents movement freezing"
})

-- Optimal Jump
local OptimalJumpToggle = Tabs.Physics:AddToggle("OptimalJump", {
    Title = "Optimal Jump",
    Default = false,
    Description = "Shows the best position to jump for catches"
})

local OptimalJumpType = Tabs.Physics:AddDropdown("OptimalJumpType", {
    Title = "Type",
    Values = {"Jump", "Dive"},
    Default = "Jump",
    Description = "Jump or dive indicator"
})

-- No Ball Trail
local NoBallTrailToggle = Tabs.Physics:AddToggle("NoBallTrail", {
    Title = "No Ball Trail",
    Default = false,
    Description = "Removes the trail behind the ball"
})

-- Big Head
local BigHeadToggle = Tabs.Physics:AddToggle("BigHead", {
    Title = "Big Head",
    Default = false,
    Description = "Increases the size of player heads"
})

local BigHeadSize = Tabs.Physics:AddSlider("BigHeadSize", {
    Title = "Size",
    Description = "Head size multiplier",
    Default = 3,
    Min = 1,
    Max = 5,
    Rounding = 0
})

-- Player Tab UI Elements
local SpeedToggle = Tabs.Player:AddToggle("Speed", {
    Title = "Speed",
    Default = false,
    Description = "Increases your movement speed"
})

local SpeedValue = Tabs.Player:AddSlider("SpeedValue", {
    Title = "Speed",
    Description = "Speed multiplier",
    Default = 22,
    Min = 20,
    Max = 23,
    Rounding = 1
})

local JumpPowerToggle = Tabs.Player:AddToggle("JumpPower", {
    Title = "Jump Power",
    Default = false,
    Description = "Increases your jump height"
})

local JumpPowerValue = Tabs.Player:AddSlider("JumpPowerValue", {
    Title = "Power",
    Description = "Jump power multiplier",
    Default = 60,
    Min = 50,
    Max = 70,
    Rounding = 0
})

local AngleAssistToggle = Tabs.Player:AddToggle("AngleAssist", {
    Title = "Angle Assist",
    Default = false,
    Description = "Boosts your angles"
})

local AngleAssistJP = Tabs.Player:AddSlider("AngleAssistJP", {
    Title = "JP",
    Description = "Jump power for angle assist",
    Default = 60,
    Min = 50,
    Max = 70,
    Rounding = 0
})

-- Add AutoCap to Auto tab
local AutoCapToggle = Tabs.Auto:AddToggle("AutoCap", {
    Title = "Auto Cap",
    Default = false,
    Description = "Makes you auto win the race for captain"
})

local AutoCapEnabled = Tabs.Auto:AddToggle("AutoCapEnabled", {
    Title = "Enabled",
    Default = false,
    Description = "Enable/disable auto cap feature"
})

-- Add QB Aimbot to Throwing tab (placeholder for now)
local QBAimbot = Tabs.Throwing:AddToggle("QBAimbot", {
    Title = "QB Aimbot",
    Default = false,
    Description = "Makes your throws more accurate"
})

Tabs.Throwing:AddParagraph({
    Title = "Coming Soon",
    Content = "QB Aimbot feature is currently in development."
})

-- Define boundaries array
local boundaries = {}

if not IS_PRACTICE then
	for index, part in pairs(workspace.Models.Boundaries:GetChildren()) do
		boundaries[#boundaries + 1] = part
	end
end

-- Add tackle extender if firetouchinterest is available and not Solara
if firetouchinterest and not IS_SOLARA then
    local TackleExtenderToggle = Tabs.Physics:AddToggle("TackleExtender", {
        Title = "Tackle Extender",
        Default = false,
        Description = "Extends your tackle reach"
    })

    local TackleExtenderRadius = Tabs.Physics:AddSlider("TackleExtenderRadius", {
        Title = "Radius",
        Description = "Tackle extension distance",
        Default = 5,
        Min = 0,
        Max = 10,
        Rounding = 0
    })

    task.spawn(function()
        while true do
            task.wait()

            local possessor = findPossessor()
            local character = player.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")

            if not hrp then continue end
            if not possessor then continue end
            if not Options.TackleExtender.Value then continue end

            local distance = (hrp.Position - possessor.HumanoidRootPart.Position).Magnitude

            if distance > Options.TackleExtenderRadius.Value then continue end

            for index, part in pairs(possessor:GetChildren()) do
                if not part:IsA("BasePart") then continue end
                if not character:FindFirstChild(part.Name) then continue end
                firetouchinterest(character:FindFirstChild(part.Name), part, 0)
                firetouchinterest(character:FindFirstChild(part.Name), part, 1)
            end
        end
    end)
end

-- Add extra features if AC_BYPASS is true
if AC_BYPASS then
    local BlockExtenderToggle = Tabs.Physics:AddToggle("BlockExtender", {
        Title = "Block Extender",
        Default = false,
        Description = "Extends your blocking range"
    })

    local BlockExtenderRange = Tabs.Physics:AddSlider("BlockExtenderRange", {
        Title = "Range",
        Description = "Block extension distance",
        Default = 10,
        Min = 1,
        Max = 20,
        Rounding = 0
    })

    local BlockExtenderTransparency = Tabs.Physics:AddSlider("BlockExtenderTransparency", {
        Title = "Transparency",
        Description = "Visual transparency of block zone",
        Default = 1,
        Min = 0,
        Max = 1,
        Rounding = 1
    })

    local flying = false
    local flySpeed = 1

    local FlyToggle = Tabs.Physics:AddToggle("Fly", {
        Title = "Fly",
        Default = false,
        Description = "Enables flight mode"
    })

    FlyToggle:OnChanged(function(Value)
        flying = Value

        if Value then
            player.Character.Humanoid.PlatformStand = true
            local bodyVelocity = Instance.new("BodyVelocity", player.Character.HumanoidRootPart)
            local camera = workspace.CurrentCamera
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            local bodyGyro = Instance.new("BodyGyro", player.Character.HumanoidRootPart)
            bodyGyro.P = 15000
            bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)

            task.spawn(function()
                while flying do
                    runService.Stepped:wait()
                    local speed = 11 + (flySpeed * 2.5)
                    local endPos = camera.CFrame.Position + camera.CFrame.LookVector * 500
                    bodyGyro.CFrame = CFrame.new(player.Character.HumanoidRootPart.Position, endPos)
                    local velocity = Vector3.new(0, 0, 0)

                    if not userInputService:GetFocusedTextBox() then
                        if userInputService:IsKeyDown(Enum.KeyCode.W) then
                            velocity += camera.CFrame.LookVector * speed
                        end
                        if userInputService:IsKeyDown(Enum.KeyCode.S) then
                            velocity += camera.CFrame.LookVector * -speed
                        end
                        if userInputService:IsKeyDown(Enum.KeyCode.A) then
                            velocity += player.Character.HumanoidRootPart.CFrame:vectorToWorldSpace(Vector3.new(-speed, 0, 0))
                        end
                        if userInputService:IsKeyDown(Enum.KeyCode.D) then
                            velocity += player.Character.HumanoidRootPart.CFrame:vectorToWorldSpace(Vector3.new(speed, 0, 0))
                        end
                    end

                    if player.Character.Humanoid.Health <= 0 then
                        flying = false
                    end

                    bodyVelocity.Velocity = velocity
                    task.wait()
                end

                player.Character.Humanoid.PlatformStand = false
                bodyGyro:Destroy()
                bodyVelocity:Destroy()
            end)
        end
    end)

    local FlySpeedSlider = Tabs.Physics:AddSlider("FlySpeed", {
        Title = "Speed",
        Description = "Flying speed multiplier",
        Default = 3,
        Min = 1,
        Max = IS_PRACTICE and 20 or 5,
        Rounding = 0
    })

    FlySpeedSlider:OnChanged(function(Value)
        flySpeed = Value
    end)

    task.spawn(function()
        while true do
            task.wait()

            local character = player.Character
            local blockPart = character and character:FindFirstChild("BlockPart")

            if not blockPart then continue end

            blockPart.Size = Options.BlockExtender.Value and Vector3.new(Options.BlockExtenderRange.Value, Options.BlockExtenderRange.Value, Options.BlockExtenderRange.Value) or Vector3.new(0.75, 5, 1.5)
            blockPart.Transparency = Options.BlockExtender.Value and Options.BlockExtenderTransparency.Value or 1
        end
    end)
end

-- Define utility functions
function getPing()
	return statsService.PerformanceStats.Ping:GetValue()
end

function getServerPing()
	return statsService.Network.ServerStatsItem['Data Ping']:GetValue()
end

function findClosestBall()
	local lowestDistance = math.huge
	local nearestBall = nil

	local character = player.Character

	for index, ball in pairs(workspace:GetChildren()) do
		if ball.Name ~= "Football" then continue end
		if not ball:IsA("BasePart") then continue end
		if not character:FindFirstChild("HumanoidRootPart") then continue end
		local distance = (ball.Position - character.HumanoidRootPart.Position).Magnitude

		if distance < lowestDistance then
			nearestBall = ball
			lowestDistance = distance
		end
	end

	return nearestBall
end

local part = Instance.new("Part")
part.Transparency = 0.5  -- Set overall transparency to 0.5
part.Anchored = true
part.CanCollide = false
part.CastShadow = false
part.Color = Color3.fromRGB(85, 170, 255) -- Light blue color
part.Shape = Enum.PartType.Ball -- Make it a sphere
part.Material = Enum.Material.ForceField -- Use ForceField material for a smooth, semi-transparent appearance
part.Parent = workspace -- Keep the part in workspace at all times so hitbox is consistently visible

function beamProjectile(g, v0, x0, t1)
	local c = 0.5*0.5*0.5;
	local p3 = 0.5*g*t1*t1 + v0*t1 + x0;
	local p2 = p3 - (g*t1*t1 + v0*t1)/3;
	local p1 = (c*g*t1*t1 + 0.5*v0*t1 + x0 - c*(x0+p3))/(3*c) - p2;

	local curve0 = (p1 - x0).magnitude;
	local curve1 = (p2 - p3).magnitude;

	local b = (x0 - p3).unit;
	local r1 = (p1 - x0).unit;
	local u1 = r1:Cross(b).unit;
	local r2 = (p2 - p3).unit;
	local u2 = r2:Cross(b).unit;
	b = u1:Cross(r1).unit;

	local cf1 = CFrame.new(
		x0.x, x0.y, x0.z,
		r1.x, u1.x, b.x,
		r1.y, u1.y, b.y,
		r1.z, u1.z, b.z
	)

	local cf2 = CFrame.new(
		p3.x, p3.y, p3.z,
		r2.x, u2.x, b.x,
		r2.y, u2.y, b.y,
		r2.z, u2.z, b.z
	)

	return curve0, -curve1, cf1, cf2;
end

function getNearestPartToPartFromParts(part, parts)
	local lowestDistance = math.huge
	local nearestPart = nil

	for index, p in pairs(parts) do
		local distance = (part.Position - p.Position).Magnitude

		if distance < lowestDistance then
			nearestPart = p
			lowestDistance = distance
		end
	end

	return nearestPart
end

task.spawn(function()
	while true do
		task.wait(0.1)
		ping = ( getPing() + getServerPing() ) / 1000
	end
end)

task.spawn(function()
	runService.RenderStepped:Connect(function()
		fps += 1
		task.delay(1, function()
			fps -= 1
		end)
	end)
end)

function findPossessor()
	for index, player in pairs(players:GetPlayers()) do
		local character = player.Character; if not character then continue end
		if not character:FindFirstChildWhichIsA("Tool") then continue end
		return player.Character
	end
end

-- Magnets Feature
local MagnetsToggle = Tabs.Catching:AddToggle("Magnets", {
    Title = "Magnets",
    Default = false,
    Description = "Helps you catch the ball"
})

local MagnetsType = Tabs.Catching:AddDropdown("MagnetsType", {
    Title = "Type",
    Values = {"Blatant", "Legit", "League"},
    Default = "League",
    Description = "How obvious the magnets behavior is"
})

local MagnetsCustomRadius = Tabs.Catching:AddSlider("MagnetsCustomRadius", {
    Title = "Radius",
    Description = "Radius for the League type",
    Default = 35,
    Min = 0,
    Max = 70,
    Rounding = 0
})

local ShowMagHitbox = Tabs.Catching:AddToggle("ShowMagHitbox", {
    Title = "Visualise Hitbox",
    Default = false,
    Description = "Displays the mag hitbox"
})

-- PullVector Feature
local PullVectorToggle = Tabs.Catching:AddToggle("PullVector", {
    Title = "Pull Vector",
    Default = false,
    Description = "Pulls you towards the ball"
})

local PullVectorDistance = Tabs.Catching:AddSlider("PullVectorDistance", {
    Title = "Distance",
    Description = "Maximum distance to activate pull",
    Default = 50,
    Min = 0,
    Max = 100,
    Rounding = 0
})

local PullVectorType = Tabs.Catching:AddDropdown("PullVectorType", {
    Title = "Type",
    Values = {"Glide", "Teleport"},
    Default = "Glide"
})

local PullVectorPower = Tabs.Catching:AddSlider("PullVectorPower", {
    Title = "Power",
    Description = "Strength of the pull effect",
    Default = 3,
    Min = 1,
    Max = 5,
    Rounding = 0
})

-- Physics UI Elements

local fakeBalls = {}
local pullVectoredBalls = {}
local velocity = {}
local isCatching = false

-- Define firetouchinterest for Solara
firetouchinterest = (IS_SOLARA) and function(part2, part1, state)
	if AC_BYPASS then
		part1.CFrame = part2.CFrame
	else
		state = state == 1
		local fakeBall = fakeBalls[part1]
		if not fakeBall then return end

		local direction = (part2.Position - fakeBall.Position).Unit
		local distance = (part2.Position - fakeBall.Position).Magnitude

		for i = 1,5,1 do
			local percentage = i/5 + Random.new():NextNumber(0.01, 0.02)
			part1.CFrame = fakeBall.CFrame + (direction * distance * percentage)
		end
	end
end or firetouchinterest

local function onCharacterCatching(character)
	local arm = character:WaitForChild('Left Arm')

	arm.ChildAdded:Connect(function(child)
		if not child:IsA("Weld") then return end
		isCatching = true
		task.wait(1.7)
		isCatching = false
	end)
end

workspace.ChildAdded:Connect(function(ball)
	if ball.Name ~= "Football" then return end
	if not ball:IsA("BasePart") then return end
	task.wait()

	local lastPosition = ball.Position
	local lastCheck = os.clock()
	local initalVelocity = ball.AssemblyLinearVelocity

	if (IS_SOLARA) and ball:FindFirstChildWhichIsA("Trail") and not ball.Anchored and camera.CameraSubject ~= ball then
		local fakeBall = ball:Clone()
		fakeBall.Name = "FFootball"
		fakeBall.Parent = workspace
		fakeBall.Anchored = true
		fakeBall.CanCollide = false
		fakeBall:FindFirstChildWhichIsA('PointLight'):Destroy()
		ball.Transparency = 1
		local spiralDegrees = 0
		fakeBalls[ball] = fakeBall
		task.spawn(function()
			while ball.Parent == workspace do
				local dt = runService.Heartbeat:Wait()
				spiralDegrees += 1500 * dt
				initalVelocity += Vector3.new(0, -28 * dt, 0)
				fakeBall.Position += initalVelocity * dt
				fakeBall.CFrame = CFrame.lookAt(fakeBall.Position, fakeBall.Position + initalVelocity) * CFrame.Angles(math.rad(90), math.rad(spiralDegrees), 0)

				if ball:FindFirstChildWhichIsA("Trail") then
					ball:FindFirstChildWhichIsA("Trail").Enabled = false
				end
			end
			fakeBall:Destroy()
		end)
	end

	while ball.Parent do
		task.wait(0.1)

		local t = (os.clock() - lastCheck)
		velocity[ball] = (ball.Position - lastPosition) / t

		lastCheck = os.clock()
		lastPosition = ball.Position
	end
end)

-- Implement magnets functionality
task.spawn(function()
    while true do
        task.wait(1/60)
        local ball = findClosestBall(); if not ball then part.Parent = nil continue end
        local character = player.Character

        if not character then continue end

        local catchPart = getNearestPartToPartFromParts(ball, {character:FindFirstChild("CatchLeft"), character:FindFirstChild("CatchRight")})

        if not catchPart then continue end
        if not velocity[ball] then continue end
        if not Options.Magnets.Value then
            part.Parent = nil
            continue
        end

        -- Update magnets functionality to match original
        if Options.MagnetsType.Value == "LegitV2" then
            Options.MagnetsType:SetValue("League")
        end

        if Options.MagnetsType.Value == "League" then
            local predictedPosition = (fakeBalls[ball] or ball).Position + (velocity[ball] * ping)
            local distance = (catchPart.Position - predictedPosition).Magnitude

            -- Position the hitbox directly at the ball position, not in front of it
            part.Position = (fakeBalls[ball] or ball).Position
            part.Size = Vector3.new(Options.MagnetsCustomRadius.Value, Options.MagnetsCustomRadius.Value, Options.MagnetsCustomRadius.Value)
            part.Parent = Options.ShowMagHitbox.Value and workspace or nil
            part.Color = Color3.fromRGB(85, 170, 255) -- Light blue color
            part.Material = Enum.Material.ForceField -- Force Field material for smooth appearance
            part.Transparency = 0.6 -- Semi-transparent as requested

            if distance > Options.MagnetsCustomRadius.Value then continue end

            firetouchinterest(catchPart, ball, 0)
            firetouchinterest(catchPart, ball, 1)
        else
            local distance = (catchPart.Position - ball.Position).Magnitude
            local radius = (Options.MagnetsType.Value == "Blatant" and 50 or 6)

            -- Position the hitbox directly at the ball position
            part.Position = (fakeBalls[ball] or ball).Position
            part.Size = Vector3.new(radius, radius, radius)
            part.Parent = Options.ShowMagHitbox.Value and workspace or nil
            part.Color = Color3.fromRGB(85, 170, 255) -- Light blue color
            part.Material = Enum.Material.ForceField -- Force Field material for smooth appearance
            part.Transparency = 0.6 -- Semi-transparent as requested

            if not isCatching and IS_SOLARA then continue end

            if distance < radius then
                firetouchinterest(catchPart, ball, 0)
                firetouchinterest(catchPart, ball, 1)
            end
        end
    end
end)

-- Implement pull vector functionality
task.spawn(function()
	while true do
		task.wait()
		local ball = findClosestBall() if not ball then continue end
		local character = player.Character
		local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

		if not ball:FindFirstChildWhichIsA("Trail") then continue end
		if not character or not humanoidRootPart then continue end
		if not Options.PullVector.Value then continue end
		if pullVectoredBalls[ball] then continue end
		if ball.Anchored then continue end

		local distance = (humanoidRootPart.Position - ball.Position).Magnitude
		if distance > Options.PullVectorDistance.Value then continue end

		local direction = (ball.Position - humanoidRootPart.Position).Unit

		if Options.PullVectorType.Value == "Teleport" then
			pullVectoredBalls[ball] = true
			local dist = 10 + ((Options.PullVectorPower.Value - 1) * 5)
			humanoidRootPart.CFrame += direction * dist
		else
			humanoidRootPart.AssemblyLinearVelocity = direction * Options.PullVectorPower.Value * 25
		end
	end
end)

onCharacterCatching(player.Character)
player.CharacterAdded:Connect(onCharacterCatching)

-- Physics Functions
local function onCharacterPhysics(char)
	local humanoid = char:WaitForChild("Humanoid")

	char.DescendantAdded:Connect(function(v)
		task.wait()
		if v.Name:match("FFmover") and Options.AntiBlock.Value then
			v:Destroy()
		end
	end)

	task.spawn(function()
		while true do
			task.wait()
			if Options.NoJumpCooldown.Value then
				humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
			end

			local torso = char:FindFirstChild("Torso")
			local head = char:FindFirstChild("Head")

			if not torso or not head then return end

			if humanoid:GetState() == Enum.HumanoidStateType.Running and values.Status.Value == "InPlay" then
				torso.CanCollide = not Options.AntiJam.Value
				head.CanCollide = not Options.AntiJam.Value
			else
				torso.CanCollide = true
				head.CanCollide = true
			end
		end
	end)
end

task.spawn(function()
	local function applyChanges(character)
		local head = character and character:FindFirstChild("Head")
		local mesh = head and head:FindFirstChildWhichIsA("SpecialMesh")

		if not mesh then return end

		mesh.MeshType = Options.BigHead.Value and Enum.MeshType.Sphere or Enum.MeshType.Head
		head.Size = Options.BigHead.Value and Vector3.new(Options.BigHeadSize.Value, 1, Options.BigHeadSize.Value) or Vector3.new(2, 1, 1)
	end

	while true do
		task.wait()

		for index, plr in pairs(players:GetPlayers()) do
			if plr == players.LocalPlayer then continue end
			applyChanges(plr.Character)
		end
	end
end)

workspace.ChildAdded:Connect(function(ball)
	task.wait()
	if ball.Name ~= "Football" then return end
	if not ball:IsA("BasePart") then return end

	if Options.NoBallTrail.Value and ball:FindFirstChildWhichIsA("Trail") then
		ball:FindFirstChildWhichIsA("Trail").Enabled = false
	end

	task.spawn(function()
		if not Options.OptimalJump.Value then return end
		local initalVelocity = ball.AssemblyLinearVelocity
		local optimalPosition = Vector3.zero

		local currentPosition = ball.Position

		local t = 0

		while true do
			t += 0.05
			initalVelocity += Vector3.new(0, -28 * 0.05, 0)
			currentPosition += initalVelocity * 0.05
			local raycastParams = RaycastParams.new()
			raycastParams.FilterDescendantsInstances = {workspace:FindFirstChild("Models")}
			raycastParams.FilterType = Enum.RaycastFilterType.Include

			local ray = workspace:Raycast(currentPosition, Vector3.new(0, Options.OptimalJumpType.Value == "Jump" and -13 or -15, 0), raycastParams)
			local antiCrashRay = workspace:Raycast(currentPosition, Vector3.new(0, -500, 0), raycastParams)

			if ray and t > 0.75 then
				optimalPosition = ray.Position + Vector3.new(0, 2, 0)
				break
			end

			if not antiCrashRay then
				optimalPosition = currentPosition
				break
			end
		end

		local part = Instance.new("Part")
		part.Anchored = true
		part.Material = Enum.Material.Neon
		part.Size = Vector3.new(1.5, 1.5, 1.5)
		part.Position = optimalPosition
		part.CanCollide = false
		part.Color = Color3.fromRGB(85, 170, 255) -- Light blue color
		part.Parent = workspace

		repeat task.wait() until ball.Parent ~= workspace

		part:Destroy()
	end)

	task.spawn(function()
		if not Options.VisualizeBallPath.Value then return end
		local initalVelocity = ball.AssemblyLinearVelocity
		local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
		a0.Parent = workspace.Terrain; a1.Parent = workspace.Terrain

		local beam = Instance.new("Beam", workspace.Terrain)
		beam.Attachment0 = a0
		beam.Attachment1 = a1
		beam.Segments = 500
		beam.Width0 = 0.5
		beam.Width1 = 0.5
		beam.Transparency = NumberSequence.new(0)
		beam.Color = ColorSequence.new(Color3.fromRGB(85, 170, 255)) -- Light blue color

		local g = Vector3.new(0, -28 ,0)
		local x0 = ball.Position
		local v0 = initalVelocity

		local curve0, curve1, cf1, cf2 = beamProjectile(g, v0, x0, 5)

		beam.CurveSize0 = curve0
		beam.CurveSize1 = curve1
		a0.CFrame = a0.Parent.CFrame:inverse() * cf1
		a1.CFrame = a1.Parent.CFrame:inverse() * cf2

		repeat task.wait() until ball.Parent ~= workspace

		beam:Destroy()
	end)
end)

local quickTPCooldown = os.clock()

userInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode ~= Options.QuickTPBind.Value then return end

	local character = player.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
	local humanoid = character and character:FindFirstChild("Humanoid")

	if not Options.QuickTP.Value then return end
	if not character or not humanoidRootPart or not humanoid then return end
	if (os.clock() - quickTPCooldown) < 0.1 then return end

	local speed = 2 + (Options.QuickTPSpeed.Value / 4)

	humanoidRootPart.CFrame += humanoid.MoveDirection * speed
	quickTPCooldown = os.clock()
end)

mouse.Button1Down:Connect(function()
	if not Options.ClickTackleAimbot.Value then return end

	local possessor = findPossessor()
	local character = player.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

	if not character or not humanoidRootPart then return end
	if not possessor then return end

	local distance = (possessor.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
	if distance > Options.ClickTackleAimbotDistance.Value then return end

	humanoidRootPart.CFrame = possessor.HumanoidRootPart.CFrame
end)

onCharacterPhysics(player.Character)
player.CharacterAdded:Connect(onCharacterPhysics)

-- Add player movement functionality
local function onCharacterMovement(character)
	local humanoid = character:WaitForChild("Humanoid")
	local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

	task.spawn(function()
		while AC_BYPASS and humanoid.Parent do
			task.wait(.1)
			humanoid.JumpPower = Options.JumpPower.Value and Options.JumpPowerValue.Value or 50
		end
	end)

	humanoid.Jumping:Connect(function()
		if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
		if AC_BYPASS then return end
		task.wait(0.05)
		if Options.JumpPower.Value then
			humanoidRootPart.AssemblyLinearVelocity += Vector3.new(0, Options.JumpPowerValue.Value - 50, 0)
		end
	end)
end

onCharacterMovement(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterMovement)

-- Add angle enhancer/assist functionality
task.spawn(function()
	local angleTick = os.clock()
	local oldLookVector = Vector3.new(0, 0, 0)

	local shiftLockEnabled = false
	local lastEnabled = false

	local function hookCharacter(character)
		local humanoid = character:WaitForChild("Humanoid")
		local hrp = character:WaitForChild("HumanoidRootPart")

		humanoid.Jumping:Connect(function()
			if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
			if os.clock() - angleTick > 0.2 then return end
			if not Options.AngleAssist.Value then return end

			if AC_BYPASS then return end

			task.wait(0.05); hrp.AssemblyLinearVelocity += Vector3.new(0, Options.AngleAssistJP.Value - 50, 0)
		end)
	end

	hookCharacter(player.Character or player.CharacterAdded:Wait())

	player.CharacterAdded:Connect(hookCharacter)

	userInputService:GetPropertyChangedSignal("MouseBehavior"):Connect(function()
		if userInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
			shiftLockEnabled = true
		else
			shiftLockEnabled = false
		end
	end)

	while true do
		task.wait()
		local character = player.Character; if not character then continue end
		local hrp = character:FindFirstChild("HumanoidRootPart"); if not hrp then continue end
		local humanoid = character:FindFirstChild("Humanoid"); if not humanoid then continue end

		local lookVector = hrp.CFrame.LookVector
		local difference = (oldLookVector - lookVector).Magnitude

		if not shiftLockEnabled and lastEnabled then
			angleTick = os.clock()
		end

		if AC_BYPASS then
			if (os.clock() - angleTick < 0.2) and Options.AngleAssist.Value then
				humanoid.JumpPower = (Options.JumpPower.Value and Options.JumpPowerValue.Value or 50) + (Options.AngleAssistJP.Value - 50)
			elseif not Options.AngleAssist.Value then
				humanoid.JumpPower = (Options.JumpPower.Value and Options.JumpPowerValue.Value or 50)
			end
		end

		oldLookVector = hrp.CFrame.LookVector
		lastEnabled = shiftLockEnabled
	end
end)

-- Implement walk speed modifying
runService:BindToRenderStep("walkSpeed", Enum.RenderPriority.Character.Value, function()
	local character = player.Character
	local humanoid = character and character:FindFirstChild("Humanoid")

	if not character or not humanoid then return end
	if humanoid:GetState() ~= Enum.HumanoidStateType.Running then return end
	if humanoid.WalkSpeed == 0 and not Options.NoFreeze.Value then return end
	if not character:FindFirstChild("HumanoidRootPart") then return end

	local moveDirection = ((os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5 and (humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit) or (humanoid.MoveDirection)
	local currentVel = character.HumanoidRootPart.AssemblyLinearVelocity

	if Options.Speed.Value or Options.NoFreeze.Value then
		local speedVal = Options.Speed.Value and (Options.SpeedValue.Value > 20 and Options.SpeedValue.Value) or 20
		character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(moveDirection.X * speedVal, currentVel.Y, moveDirection.Z * speedVal)
	end
end)

-- Implement AutoCap functionality
local finishLine = not IS_PRACTICE and workspace.Models.LockerRoomA.FinishLine or Instance.new('Part')

task.spawn(function()
    while true do
        task.wait()
        if not Options.AutoCap.Value or not Options.AutoCapEnabled.Value then continue end
        if IS_PRACTICE then continue end

        local character = player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end

        local distance = (hrp.Position - finishLine.Position).Magnitude

        if distance < 10 then
            local possessor = findPossessor()
            if not possessor then continue end

            local possessorIsLocalPlayer = possessor == character
            if possessorIsLocalPlayer then
                -- Auto cap when in proximity to finish line and possessing the ball
                local event = game:GetService("ReplicatedStorage").Remotes.Touchdown
                if event then
                    event:FireServer()
                end
            end
        end
    end
end)

-- Configuration and settings management
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})

InterfaceManager:SetFolder("EclipseHub")
SaveManager:SetFolder("EclipseHub/ff2")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Add save/load configuration buttons
Tabs.Settings:AddButton({
    Title = "Save Config",
    Description = "Save current configuration",
    Callback = function()
        Fluent:Notify({
            Title = "Config System",
            Content = "Enter a name for your config in the prompt",
            Duration = 3
        })

        local configName = nil
        local success, result = pcall(function()
            return Fluent:Prompt({
                Title = "Save Configuration",
                Content = "Enter a name for your configuration",
                TextBoxValue = "",
                Buttons = {
                    {
                        Title = "Save",
                        Callback = function(textBoxValue)
                            configName = textBoxValue
                            return true
                        end
                    },
                    {
                        Title = "Cancel",
                        Callback = function()
                            return false
                        end
                    }
                }
            })
        end)

        if success and result and configName and #configName > 0 then
            local exported = SaveManager:SaveConfiguration(configName)
            if exported then
                Fluent:Notify({
                    Title = "Config System",
                    Content = "Configuration saved as " .. configName,
                    Duration = 3
                })
            end
        end
    end
})

Tabs.Settings:AddButton({
    Title = "Load Config",
    Description = "Load a saved configuration",
    Callback = function()
        SaveManager:LoadConfiguration()
    end
})

-- Select first tab
Window:SelectTab(1)

Fluent:Notify({
    Title = "Eclipse Hub",
    Content = "Script successfully loaded. Use the tabs to navigate features.",
    Duration = 5
})
